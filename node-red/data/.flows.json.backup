[
    {
        "id": "17bc7aeebae10c16",
        "type": "tab",
        "label": "Flow 1",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "a8cb1e729a2b76ed",
        "type": "mqtt-broker",
        "name": "mosquitto",
        "broker": "mosquitto",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "c2d51192a5e06b33",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": "8086",
        "protocol": "http",
        "database": "database",
        "name": "InfluxDB",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb:8086",
        "timeout": "10",
        "rejectUnauthorized": true
    },
    {
        "id": "37409ed0ed704cfc",
        "type": "telegram bot",
        "botname": "MyAirQualityMonitoringBot",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "addressfamily": "",
        "pollinterval": 300,
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": 6667,
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbotport": 8443,
        "publicbotport": 8443,
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    },
    {
        "id": "4439cfb539ede99d",
        "type": "telegram bot",
        "botname": "MyAirQualityManagerBot",
        "usernames": "",
        "chatids": "",
        "baseapiurl": "",
        "testenvironment": false,
        "updatemode": "polling",
        "addressfamily": "",
        "pollinterval": 300,
        "usesocks": false,
        "sockshost": "",
        "socksprotocol": "socks5",
        "socksport": 6667,
        "socksusername": "anonymous",
        "sockspassword": "",
        "bothost": "",
        "botpath": "",
        "localbotport": 8443,
        "publicbotport": 8443,
        "privatekey": "",
        "certificate": "",
        "useselfsignedcertificate": false,
        "sslterminated": false,
        "verboselogging": false
    },
    {
        "id": "63af76c7f02179a7",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "InfluxDB",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb:8086",
        "timeout": 10,
        "rejectUnauthorized": true
    },
    {
        "id": "ae13f6ea803c0377",
        "type": "debug",
        "z": "17bc7aeebae10c16",
        "name": "Print data format",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 790,
        "y": 80,
        "wires": []
    },
    {
        "id": "ee28238ae82ab55c",
        "type": "mqtt in",
        "z": "17bc7aeebae10c16",
        "name": "",
        "topic": "/smartcities/#",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "a8cb1e729a2b76ed",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 90,
        "y": 140,
        "wires": [
            [
                "49c93715f58ab854"
            ]
        ]
    },
    {
        "id": "49c93715f58ab854",
        "type": "function",
        "z": "17bc7aeebae10c16",
        "name": "Data Preprocessing",
        "func": "// msg.measurement = msg.payload.sensor_type; \n// msg.payload = [\n//     {\n//         value: parseFloat(msg.payload.value), //field\n//         latitude: parseFloat(msg.payload.latitude), //field\n//         longitude: parseFloat(msg.payload.longitude), //field\n//     },\n//     {\n//         city: msg.payload.city, //tag\n//         sensor_id: msg.payload.sensor_id, //tag\n//         sensor_type: msg.payload.sensor_type //tag\n//     },\n//     {\n//         timestamp: msg.payload.time || Date.now() //timestamp\n//     }\n// ];\n// return msg;\n\n// AQI Breakpoints for PM2.5 and PM10\nconst AQI_BREAKPOINTS = {\n    pm2_5: [\n        { concentrationLow: 0, concentrationHigh: 12, AQILow: 0, AQIHigh: 50 },\n        { concentrationLow: 12.1, concentrationHigh: 35.4, AQILow: 51, AQIHigh: 100 },\n        { concentrationLow: 35.5, concentrationHigh: 55.4, AQILow: 101, AQIHigh: 150 },\n        { concentrationLow: 55.5, concentrationHigh: 150.4, AQILow: 151, AQIHigh: 200 },\n        { concentrationLow: 150.5, concentrationHigh: 250.4, AQILow: 201, AQIHigh: 300 },\n    ],\n    pm10: [\n        { concentrationLow: 0, concentrationHigh: 54, AQILow: 0, AQIHigh: 50 },\n        { concentrationLow: 55, concentrationHigh: 154, AQILow: 51, AQIHigh: 100 },\n        { concentrationLow: 155, concentrationHigh: 254, AQILow: 101, AQIHigh: 150 },\n        { concentrationLow: 255, concentrationHigh: 354, AQILow: 151, AQIHigh: 200 },\n        { concentrationLow: 355, concentrationHigh: 424, AQILow: 201, AQIHigh: 300 },\n    ]\n};\n\n// Function to calculate AQI\nfunction calculateAQI(sensorType, value) {\n    const breakpoints = AQI_BREAKPOINTS[sensorType];\n    if (!breakpoints) return null; // No AQI calculation for this sensor type\n\n    for (const breakpoint of breakpoints) {\n        if (value >= breakpoint.concentrationLow && value <= breakpoint.concentrationHigh) {\n            return ((breakpoint.AQIHigh - breakpoint.AQILow) / \n                    (breakpoint.concentrationHigh - breakpoint.concentrationLow)) *\n                    (value - breakpoint.concentrationLow) + breakpoint.AQILow;\n        }\n    }\n    return null; // Value is out of range\n}\n\n// Process data based on sensor type\nmsg.measurement = msg.payload.sensor_type; // Use sensor_type as measurement name\n\nlet value = parseFloat(msg.payload.value);\nlet aqi = null; // Default AQI value\n\n// Calculate AQI only for PM2.5 and PM10\nif (msg.payload.sensor_type === \"pm2_5\" || msg.payload.sensor_type === \"pm10\") {\n    aqi = calculateAQI(msg.payload.sensor_type, value);\n}\n\n// Format payload\nmsg.payload = [\n    {\n        value: value, // Field\n        latitude: parseFloat(msg.payload.latitude), // Field\n        longitude: parseFloat(msg.payload.longitude), // Field\n        aqi: aqi // Add AQI as a field (null for non-AQI types)\n    },\n    {\n        city: msg.payload.city, // Tag\n        sensor_id: msg.payload.sensor_id, // Tag\n        sensor_type: msg.payload.sensor_type // Tag\n    },\n        {measurement: msg.payload.sensor_type},\n    {\n        timestamp: msg.payload.time || Date.now() // Timestamp\n    }\n];\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 140,
        "wires": [
            [
                "0fef79229c570c5b"
            ]
        ]
    },
    {
        "id": "a8d8bd74d7d194df",
        "type": "influxdb out",
        "z": "17bc7aeebae10c16",
        "influxdb": "c2d51192a5e06b33",
        "name": "Write to InfluxDB",
        "measurement": "",
        "precision": "",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "my_org",
        "bucket": "air_quality",
        "x": 790,
        "y": 140,
        "wires": []
    },
    {
        "id": "08b6c15c01518af0",
        "type": "telegram sender",
        "z": "17bc7aeebae10c16",
        "name": "MyAirQualityMonitoringBot",
        "bot": "37409ed0ed704cfc",
        "haserroroutput": false,
        "outputs": 1,
        "x": 760,
        "y": 340,
        "wires": [
            []
        ]
    },
    {
        "id": "b0ba56552de82c50",
        "type": "function",
        "z": "17bc7aeebae10c16",
        "name": "Threshold evaluation",
        "func": "// const thresholds = global.get(\"thresholds\", \"file\") || {\n//     pm2_5: 80,         // µg/m³\n//     pm10: 80,          // µg/m³\n//     co2: 1000,         // ppm\n//     no2: 70,           // µg/m³\n//     temperature: 45,   // °C\n//     humidity: 70,      // %\n//     power_consumption: 2.0 // kW\n// };\n\n// const valueData = msg.payload[0]; // { value, latitude, longitude }\n// const metaData = msg.payload[1]; // { city, sensor_id, sensor_type }\n// const timestampData = msg.payload[2]; // { timestamp }\n\n// let alerts = [];\n\n// if (valueData.value > thresholds[metaData.sensor_type]) {\n//     alerts.push({\n//         domain: \"Smart Cities\",\n//         sensor: metaData.sensor_id,\n//         location: `${metaData.city} (${valueData.latitude}, ${valueData.longitude})`,\n//         condition: `${metaData.sensor_type} exceeds threshold: ${valueData.value}`\n//     });\n// }\n\n// if (alerts.length > 0) {\n//     let alertMessage = `🚨 *Alert for ${metaData.city}* 🚨\\n\\n`;\n\n//     alerts.forEach(alert => {\n//         alertMessage += `*Domain:* ${alert.domain}\\n`;\n//         alertMessage += `*Sensor:* ${alert.sensor}\\n`;\n//         alertMessage += `*Location:* ${alert.location}\\n`;\n//         alertMessage += `*Condition:* ${alert.condition}\\n\\n`;\n//     });\n\n//     msg.payload = {\n//         chatId: parseInt(env.get(\"NODE_RED_TELEGRAM_MONITORING_CHAT_ID\"), 10) || \"-4603413735\", \n//         type: \"message\",\n//         content: `${alertMessage}`\n//     };\n\n//     return msg;\n// } else {\n//     return null;\n// }\n\n// Load thresholds from the global context or define default values\nconst thresholds = global.get(\"thresholds\", \"file\") || {\n    pm2_5: 80,         // µg/m³\n    pm10: 80,          // µg/m³\n    co2: 1000,         // ppm\n    no2: 70,           // µg/m³\n    temperature: 45,   // °C\n    humidity: 70,      // %\n    power_consumption: 2.0 // kW\n};\n\nlet payload = msg.payload; // Aggregated data from the Data Aggregation node\nlet alerts = [];\n\n// Process each sensor entry\npayload.forEach(sensorData => {\n    const { measurement, fields, tags, timestamp } = sensorData;\n\n    // Check if the value exceeds the threshold\n    if (fields.value > thresholds[measurement]) {\n        alerts.push({\n            domain: \"Smart Cities\",\n            sensor: tags.sensor_id,\n            location: `${tags.city} (${fields.latitude}, ${fields.longitude})`,\n            condition: `${measurement} exceeds threshold: ${fields.value} (Threshold: ${thresholds[measurement]})`,\n            severity: determineSeverity(measurement), // Optional severity level\n            timestamp: timestamp\n        });\n    }\n});\n\n// Helper function to determine alert severity\nfunction determineSeverity(measurement) {\n    if ([\"pm2_5\", \"pm10\"].includes(measurement)) {\n        return \"RED\";\n    } else if ([\"co2\", \"temperature\"].includes(measurement)) {\n        return \"ORANGE\";\n    } else if ([\"humidity\", \"power_consumption\"].includes(measurement)) {\n        return \"YELLOW\";\n    } else {\n        return \"GREEN\";\n    }\n}\n\n// If there are alerts, prepare the message payload\nif (alerts.length > 0) {\n    let alertMessage = `🚨 *Alert for Multiple Locations* 🚨\\n\\n`;\n\n    alerts.forEach(alert => {\n        alertMessage += `*Domain:* ${alert.domain}\\n`;\n        alertMessage += `*Sensor:* ${alert.sensor}\\n`;\n        alertMessage += `*Location:* ${alert.location}\\n`;\n        alertMessage += `*Condition:* ${alert.condition}\\n`;\n        alertMessage += `*Severity:* ${alert.severity}\\n\\n`;\n    });\n\n    msg.payload = {\n        chatId: parseInt(env.get(\"NODE_RED_TELEGRAM_MONITORING_CHAT_ID\"), 10) || \"-4603413735\",\n        type: \"message\",\n        content: alertMessage\n    };\n\n    return msg;\n} else {\n    // No alerts\n    return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 340,
        "wires": [
            [
                "08b6c15c01518af0"
            ]
        ]
    },
    {
        "id": "fc34941c0956f03a",
        "type": "debug",
        "z": "17bc7aeebae10c16",
        "name": "Print alert data format",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 740,
        "y": 400,
        "wires": []
    },
    {
        "id": "9efc7ad82e752d8b",
        "type": "telegram receiver",
        "z": "17bc7aeebae10c16",
        "name": "MyAirQualityManagerBot receiver",
        "bot": "4439cfb539ede99d",
        "saveDataDir": "",
        "filterCommands": false,
        "x": 150,
        "y": 460,
        "wires": [
            [
                "70e16229975928be"
            ],
            []
        ]
    },
    {
        "id": "70e16229975928be",
        "type": "function",
        "z": "17bc7aeebae10c16",
        "name": "Threshold configuration",
        "func": "let thresholds = global.get(\"thresholds\") || {\n    pm2_5: 50,          // µg/m³\n    pm10: 50,           // µg/m³\n    co2: 1000,          // ppm\n    no2: 50,            // µg/m³\n    temperature: 35,    // °C\n    humidity: 70,       // %\n    power_consumption: 1.0 // kW\n};\n\nconst message = msg.payload.content;\nconst chatId = msg.payload.chatId;\n\nconst availableCommands = `\nℹ️ *Available Commands:*\n1️⃣ /get_thresholds - View current thresholds.\n2️⃣ /set_threshold <metric> <value> - Update a threshold (e.g., /set_threshold pm2_5 45).\n`;\n\nif (message === \"/get_thresholds\") {\n    msg.payload = {\n        chatId: chatId,\n        type: \"message\",\n        content: `📊 *Current Thresholds:*\\n\\n${Object.entries(thresholds)\n            .map(([key, value]) => `*${key}:* ${value}`)\n            .join(\"\\n\")}`\n    };\n    return msg;\n}\n\nif (message.startsWith(\"/set_threshold\")) {\n    const parts = message.split(\" \");\n    if (parts.length === 3) {\n        const metric = parts[1];\n        const value = parseFloat(parts[2]);\n\n        if (thresholds.hasOwnProperty(metric)) {\n            thresholds[metric] = value; // Update the threshold\n            global.set(\"thresholds\", thresholds); // Persist the updated thresholds\n            node.warn(\"Updated thresholds: \" + JSON.stringify(thresholds)); // Debug log\n\n            msg.payload = {\n                chatId: chatId,\n                type: \"message\",\n                content: `✅ Threshold for ${metric.toUpperCase()} set to ${value}`\n            };\n            return msg;\n        } else {\n            msg.payload = {\n                chatId: chatId,\n                type: \"message\",\n                content: `❌ Invalid metric. Available metrics: ${Object.keys(thresholds).join(\", \")}`\n            };\n            return msg;\n        }\n    } else {\n        msg.payload = {\n            chatId: chatId,\n            type: \"message\",\n            content: `❌ Invalid command format. Use: /set_threshold <metric> <value>\\n\\n${availableCommands}`\n        };\n        return msg;\n    }\n}\n\n// Fallback message for unrelated or unrecognized commands\nmsg.payload = {\n    chatId: chatId,\n    type: \"message\",\n    content: `❓ Unrecognized command or message. Please use one of the following commands:\\n${availableCommands}`\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 450,
        "y": 460,
        "wires": [
            [
                "bd7a7e42b72cef62"
            ]
        ]
    },
    {
        "id": "53ab33a4528ed1bb",
        "type": "debug",
        "z": "17bc7aeebae10c16",
        "name": "Print bot manager messages",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 520,
        "wires": []
    },
    {
        "id": "bd7a7e42b72cef62",
        "type": "telegram sender",
        "z": "17bc7aeebae10c16",
        "name": "MyAirQualityManagerBot sender",
        "bot": "4439cfb539ede99d",
        "haserroroutput": false,
        "outputs": 1,
        "x": 740,
        "y": 460,
        "wires": [
            []
        ]
    },
    {
        "id": "0fef79229c570c5b",
        "type": "join",
        "z": "17bc7aeebae10c16",
        "name": "Data aggregation",
        "mode": "custom",
        "build": "array",
        "property": "payload",
        "propertyType": "msg",
        "key": "payload[1].sensor_type",
        "joiner": "\\n",
        "joinerType": "str",
        "useparts": false,
        "accumulate": false,
        "timeout": "10",
        "count": "10",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 520,
        "y": 140,
        "wires": [
            [
                "3af8cdd0b2dedfde"
            ]
        ]
    },
    {
        "id": "9e895c89bb808370",
        "type": "influxdb batch",
        "z": "17bc7aeebae10c16",
        "influxdb": "63af76c7f02179a7",
        "precision": "",
        "retentionPolicy": "",
        "name": "Batch write to InfluxDB",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "my_org",
        "bucket": "air_quality",
        "x": 790,
        "y": 200,
        "wires": []
    },
    {
        "id": "3af8cdd0b2dedfde",
        "type": "function",
        "z": "17bc7aeebae10c16",
        "name": "Batch Processing",
        "func": "// Input: Aggregated payload from join node\nlet payload = msg.payload; // Array of sensor data\nlet aggregatedData = [];\n\n//msg.measurement = msg.payload.sensor_type; \n\n// Process each sensor data entry\npayload.forEach(sensorData => {\n    const fields = sensorData[0]; // Extract fields (value, latitude, longitude, aqi)\n    const tags = sensorData[1]; // Extract tags (city, sensor_id, sensor_type)\n    const timestamp = sensorData[2].timestamp; // Extract timestamp\n\n    // Prepare the aggregated format\n    // aggregatedData.push([\n    //     {\n    //         value: fields.value, // Numeric value\n    //         latitude: fields.latitude, // Latitude\n    //         longitude: fields.longitude, // Longitude\n    //         aqi: fields.aqi // AQI (null for non-AQI types)\n    //     },\n    //     {\n    //         city: tags.city, // City name\n    //         sensor_id: tags.sensor_id // Sensor ID\n    //     },\n    //     { timestamp: timestamp },  \n    // ]);\n\n    aggregatedData.push({\n        measurement: tags.sensor_type, // Use sensor_type as measurement\n        fields: {\n            value: fields.value, // Numeric value\n            latitude: fields.latitude, // Latitude\n            longitude: fields.longitude, // Longitude\n            aqi: fields.aqi // AQI (null for non-AQI types)\n        },\n        tags: {\n            city: tags.city, // City name\n            sensor_id: tags.sensor_id, // Sensor ID\n            sensor_type: tags.sensor_type\n        },\n        timestamp: timestamp // Timestamp in milliseconds\n    });\n});\n\n// Set the aggregated data as the new payload\nmsg.payload = aggregatedData;\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 220,
        "wires": [
            [
                "9e895c89bb808370"
            ]
        ]
    }
]